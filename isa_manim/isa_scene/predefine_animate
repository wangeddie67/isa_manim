"""
Predefined Animation
"""

from typing import List
from manim import (AnimationGroup, Succession, FadeIn, FadeOut,
                   LEFT, RIGHT)
from colour import Color
from ..isa_objects import (OneDimReg, OneDimRegElem, TwoDimReg, FunctionCall)
from .isa_animate import IsaAnimate
from ..isa_config import get_scene_ratio

#
# Animation with Registers.
#
def read_scalar_reg(text: str,
                    color: Color,
                    width: int,
                    **kargs) -> IsaAnimate:
    """
    Read scalar register.

    Args:
        text_list:
        color:
        width:
    """
    scalar = OneDimReg(text=text,
                       color=color,
                       width=width,
                       elements=1,
                       font_size=40,
                       **kargs)
    animate = FadeIn(scalar)
    return IsaAnimate(animate=animate, src=None, dst=scalar)

def read_vector_reg(text: str,
                    color: Color,
                    width: int,
                    elements: int = 1,
                    **kargs) -> IsaAnimate:
    """
    Read vector register.

    Args:
        text_list:
        color:
        width:
        elements:
    """
    vector = OneDimReg(text=text,
                       color=color,
                       width=width,
                       elements=elements,
                       font_size=40,
                       **kargs)
    animate = FadeIn(vector)
    return IsaAnimate(animate=animate, src=None, dst=vector)

def read_vector_group(text_list: List[str],
                      color: Color,
                      width: int,
                      elements: int = 1,
                      **kargs) -> IsaAnimate:
    """
    Read vector register group.

    Args:
        text_list:
        color:
        width:
        elements:
    """
    vector_list = []
    for text in text_list:
        vector = OneDimReg(text=text,
                           color=color,
                           width=width,
                           elements=elements,
                           font_size=40,
                           **kargs)
        vector_list.append(vector)
    animate = FadeIn(*vector_list)
    return IsaAnimate(animate=animate, src=None, dst=vector_list)

def read_2d_vector_reg(text_list: List[str],
                       color: Color,
                       nreg: int,
                       width: int,
                       elements: int = 1,
                       **kargs) -> IsaAnimate:
    """
    Read vector register group.

    Args:
        text_list:
        color:
        width:
        elements:
    """
    vector = TwoDimReg(text=text_list,
                       color=color,
                       nreg=nreg,
                       width=width,
                       elements=elements,
                       font_size=40,
                       **kargs)
    animate = FadeIn(vector)
    return IsaAnimate(animate=animate, src=None, dst=vector)

def replace_vector(vector: OneDimReg,
                   text: str,
                   color: Color,
                   width: int,
                   elements: int = 1,
                   align: str = "center",
                   **kargs):
    """
    Convert predicate as counter to marked predicate.

    Animation from [png_obj] to a new vector [predicate]
    Animation:
    - fade out png_obj and fade in predicate.

    Args:
        png_obj: Predicate as counter.
        text: Register name after conversion.
        color: Color of new element.
        width: Width of register, in Byte.
        elements: Number of elements.
        **kargs: Arguments to new element.
    """

    new_vector = OneDimReg(text=text,
                           color=color,
                           width=width,
                           elements=elements,
                           font_size=40,
                           **kargs)
    if align == "center":
        new_vector.shift(vector.get_reg_center() - new_vector.get_reg_center())
    elif align == "right":
        new_vector_pos = vector.reg_rect.get_right() + LEFT * new_vector.reg_rect.width / 2
        new_vector.shift(vector.get_reg_center() - new_vector_pos)
    elif align == "left":
        new_vector_pos = vector.reg_rect.get_left() + RIGHT * new_vector.reg_rect.width / 2
        new_vector.shift(vector.get_reg_center() - new_vector_pos)
    animate=AnimationGroup(FadeIn(new_vector), FadeOut(vector))
    return IsaAnimate(animate=animate, src=vector, dst=new_vector)

def concat_vector(vector_list: List[OneDimReg],
                  text: str,
                  color: Color,
                  **kargs) -> IsaAnimate:
    """
    Concat two vectors.

    Move v1 to left by half, move v2 to right by half, and up to align with v1.
    Fadeout v1 and v2, while fadein new vector.

    Animation from [v1,v2] to a new vector [vector]
    Animation has two step:
    - move v1 and v2
    - fade out v1/v2 and fade in vector.

    Args:
        src1: Vector 1.
        src2: Vector 2.
        text: Register name after conversion.
        color: Color of new element.
        **kargs: Arguments to new element.
    """
    reg_width_list = [item.reg_width for item in vector_list]
    reg_width = sum(reg_width_list)
    elem_width = int(min([item.elem_width for item in vector_list]))
    elements = int(reg_width / elem_width)

    vector = OneDimReg(text=text,
                       color=color,
                       width=reg_width,
                       elements=elements,
                       font_size=40,
                       **kargs)

    offset_list = [reg_width_list[0:i] for i in range(0, len(reg_width_list))]
    pos_list = vector.reg_rect

    move_animate = AnimationGroup(
        src1.animate.move_to(src1.get_center() + LEFT * src1.get_reg_width() / 2),
        src2.animate.move_to(src1.get_center() + RIGHT * src2.get_reg_width() / 2))

    fade_animate = AnimationGroup(FadeIn(vector), FadeOut(src1), FadeOut(src2))

    animate = Succession(move_animate, fade_animate)
    return IsaAnimate(animate=animate, src=[src1, src2], dst=vector)

#
# Animation with Elements.
#
def read_elem(vector: OneDimReg,
              color: Color,
              size: float = -1.0,
              reg_idx: int = 0,
              index: int = 0,
              **kargs) -> IsaAnimate:
    """
    Read element from register, return one Rectangle.

    If the element size is not specified, create element with the same width as
    elements in source register. Otherwise, create element with the new
    specified size.

    Args:
        vector: Register.
        color: Color of new element.
        size: Width of element in byte.
        e: Index of element.
        kargs: Arguments to new element.
    """

    if isinstance(vector, OneDimReg):
        elem = vector.get_elem(color=color,
                               elem_width=size,
                               index=index,
                               **kargs)
        animate = FadeIn(elem)
        return IsaAnimate(animate=animate, src=vector, dst=elem, dep=[vector])
    elif isinstance(vector, TwoDimReg):
        elem = vector.get_elem(color=color,
                               elem_width=size,
                               reg_idx=reg_idx,
                               index=index,
                               **kargs)
        animate = FadeIn(elem)
        return IsaAnimate(animate=animate, src=vector, dst=elem, dep=[vector])
    else:
        error_str = f"vector is not right type. {str(vector)}"
        raise ValueError(error_str)

def assign_elem(elem: OneDimRegElem,
                vector: OneDimReg,
                size: float = -1.0,
                reg_idx: int = 0,
                index: int = 0) -> IsaAnimate:
    """
    Assign element to register, return animation.

    If the new size is not specified, keep the size of element. Otherwise, scale element to the new 
    specified size.

    Args:
        elem: Element object.
        vector: Register.
        size: Width of destination element in byte.
        index: Index of element.
    """
    if size < 0:
        size = elem.elem_width

    if isinstance(vector, OneDimReg):
        dest_pos = vector.get_elem_center(index=index, elem_width=size)
    elif isinstance(vector, TwoDimReg):
        dest_pos = vector.get_elem_center(reg_idx=reg_idx, index=index, elem_width=size)
    else:
        error_str = f"vector is not right type. {str(vector)}"
        raise ValueError(error_str)


    # Calculate scaling factor
    old_width = elem.get_elem_width() * get_scene_ratio()
    new_width = size * get_scene_ratio()
    scale = new_width / old_width

    if scale != 1.0:
        animate = elem.animate.move_to(dest_pos).stretch(scale, 0)
    else:
        animate = elem.animate.move_to(dest_pos)

    return IsaAnimate(animate=animate, src=elem, dst=elem, dep=[vector])

def replace_elem(elem: OneDimRegElem,
                 color: Color,
                 size: int,
                 index: int,
                 align: str = "right",
                 value = None,
                 **kwargs) -> IsaAnimate:
    """
    Convert data to another element.

    Args:
        elem: Source element.
        color: Color of destination register.
        size: Size of new element.
        index: Index of new element related to source elements.
        value:
        **kargs: Arguments to new element.
    
    Return:
        - New elements.
        - Animation.
    """

    new_elem = OneDimRegElem(color=color,
                             width=size,
                             fill_opacity=0.5,
                             value=value,
                             **kwargs)
    if align == "right":
        new_elem.move_to(elem.get_sub_elem_center(index=index, elem_width=size))
    elif align == "center":
        new_elem.move_to(elem.elem_rect.get_center())
    animate=AnimationGroup(FadeIn(new_elem), FadeOut(elem))
    return IsaAnimate(animate=animate, src=elem, dst=new_elem)

#
# Animation with functions.
#
def def_func_call(func: str,
                  color: Color,
                  args_width: List[float],
                  res_width: float,
                  **kwargs) -> IsaAnimate:
    """
    Convert data to another element.

    Args:
        elem: Source element.
        color: Color of destination register.
        size: Size of new element.
        index: Index of new element related to source elements.
    
    Return:
        - New elements.
        - Animation.
    """

    func_object = FunctionCall(text=func,
                               color=color,
                               args_width=args_width,
                               res_width=res_width,
                               **kwargs)
    animate = FadeIn(func_object)
    return IsaAnimate(animate=animate, src=[], dst=func_object)

def function_call(func: FunctionCall,
                  args: List[OneDimRegElem],
                  color: Color,
                  width: float,
                  value = None,
                  **kwargs) -> IsaAnimate:
    """
    Convert data to another element.

    Args:
        elem: Source element.
        color: Color of destination register.
        size: Size of new element.
        index: Index of new element related to source elements.
    
    Return:
        - New elements.
        - Animation.
    """

    dst_elem = OneDimRegElem(color=color,
                             width=width,
                             fill_opacity=0.5,
                             value=value,
                             font_size=40,
                             **kwargs)
    dst_elem.move_to(func.get_dst_pos())

    move_animate = \
        AnimationGroup(*[arg.animate.move_to(func.get_args_pos(i)) for i, arg in enumerate(args)])
    fade_animate = \
        AnimationGroup(
            FadeIn(dst_elem, shift=func.get_dst_pos() - func.func_ellipse.get_center()),
            *[FadeOut(arg, shift=func.func_ellipse.get_center() - func.get_args_pos(i))
               for i, arg in enumerate(args)]
        )
    animate = Succession(move_animate, fade_animate)
    return IsaAnimate(animate=animate, src=args, dst=dst_elem, dep=func)
